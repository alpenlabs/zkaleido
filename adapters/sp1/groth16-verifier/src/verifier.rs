use bn::{AffineG1, Fr, G1};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use zkaleido::{ProofReceipt, ZkVmError, ZkVmResult, ZkVmVerifier};

use crate::{
    error::{Error, Groth16Error},
    types::{proof::Groth16Proof, vk::Groth16VerifyingKey},
    utils::{blake3_hash, hash_public_inputs_with_fn, sha256_hash},
    verification::verify_sp1_groth16_algebraic,
};

/// Number of bytes used from the SHA-256 hash of the Groth16 verifying key.
/// SP1 prepends these bytes to each raw Groth16 proof to ensure the proof
/// was generated with the expected verifying key.
pub(crate) const VK_HASH_PREFIX_LENGTH: usize = 4;

/// A verifier for Groth16 proofs generated by SP1.
///
/// This verifier is agnostic to the specific SP1 version, as long as the
/// proving/verifying interface remains consistent. It checks that:
/// 1. The proof was generated with the expected Groth16 verifying key (by comparing the first
///    `VK_HASH_PREFIX_LENGTH` bytes of the key’s SHA-256 hash).
/// 2. The Groth16 proof is valid with respect to two public inputs:
///    - `program_vk_hash`: a unique identifier for the SP1 program (as an Fr element).
///    - a hash of the supplied public values (either SHA-256 or Blake3).
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SP1Groth16Verifier {
    /// The (uncompressed) Groth16 verifying key for the SP1 circuit.
    pub(crate) vk: Groth16VerifyingKey,
    /// First `VK_HASH_PREFIX_LENGTH` bytes of `Sha256(groth16_vk)`, used to confirm
    /// the proof was generated with the correct key.
    pub(crate) vk_hash_tag: [u8; 4],
}

impl SP1Groth16Verifier {
    /// Loads a new `SP1Groth16Verifier` from a gnark compressed Groth16 verifying key and a
    /// program ID. This also directly bakes the SP1 `program_vk_hash` (the first public input)
    /// into the G1-key vector so that downstream you only ever need to pass the remaining inputs
    /// (e.g. the hash of your public values)
    ///
    /// # Parameters
    /// - `vk_bytes`: Byte slice containing the gnark compressed Groth16 verifying key. Typically,
    ///   this is the [`static@sp1_verifier::GROTH16_VK_BYTES`] constant for the given SP1 version.
    /// - `program_id`: A 32-byte array representing the Fr-element identifier for the SP1 program.
    ///
    /// # Returns
    /// - `Ok(SP1Groth16Verifier)`: If the verifying key and program ID are successfully parsed.
    /// - `Err(Error)`: If `vk_bytes` is invalid or cannot be parsed into a verifying key.
    pub fn load(vk_bytes: &[u8], program_vk_hash: [u8; 32]) -> Result<Self, Groth16Error> {
        // Compute the SHA-256 hash of `vk_bytes` and take the first `VK_HASH_PREFIX_LENGTH` bytes.
        // This prefix is prepended to every raw Groth16 proof by SP1 to signal which verifying key
        // was used during proving.
        let groth16_vk_hash: [u8; 4] = Sha256::digest(vk_bytes)[..VK_HASH_PREFIX_LENGTH]
            .try_into()
            .map_err(|_| Groth16Error::GeneralError(Error::InvalidData))?;

        // Parse the Groth16 verifying key from its byte representation.
        // This returns a `Groth16VerifyingKey` that can be used for algebraic verification.
        let mut groth16_vk = Groth16VerifyingKey::load_from_gnark_bytes(vk_bytes)?;

        // Parse the program ID (Fr element) from its 32-byte big-endian encoding.
        let program_vk_hash =
            Fr::from_slice(&program_vk_hash).map_err(|_| Error::FailedToGetFrFromRandomBytes)?;

        // compute K₀' = K₀ + program_vk_hash * K₁
        let k0: G1 = groth16_vk.g1.k[0].into();
        let k1: G1 = groth16_vk.g1.k[1].into();
        let k0_prime: G1 = k0 + (k1 * program_vk_hash);

        groth16_vk.g1.k = vec![
            AffineG1::from_jacobian(k0_prime).unwrap().into(),
            *groth16_vk.g1.k.last().unwrap(),
        ];

        Ok(SP1Groth16Verifier {
            vk: groth16_vk,
            vk_hash_tag: groth16_vk_hash,
        })
    }

    /// Verifies a Groth16 proof against the given public values.
    ///
    /// The proof is expected to be encoded as:
    /// [ vk_hash_prefix (VK_HASH_PREFIX_LENGTH bytes) || raw_groth16_proof_bytes ]
    ///
    /// # Parameters
    /// - `proof`: Byte slice containing the prefixed Groth16 proof.
    /// - `public_values`: Byte slice representing the public values for the SP1 circuit.
    ///
    /// HACK: Because the proof format currently does not encode which hash function (SHA-256 vs.
    /// Blake3) was used to compute the public-values hash, we attempt verification with both:
    /// first using SHA-256, and if that fails, retrying with Blake3. In future versions, this
    /// could be improved by embedding a hash-selector byte in the proof to avoid redundant checks.
    pub fn verify(&self, proof: &[u8], public_values: &[u8]) -> Result<(), Groth16Error> {
        // Ensure the proof is at least as long as the hash prefix.
        if proof.len() < VK_HASH_PREFIX_LENGTH {
            return Err(Groth16Error::GeneralError(Error::InvalidData));
        }

        // Compare the leading bytes of `proof` with our cached verifying-key hash. If they differ,
        // the proof was not generated with this verifying key.
        if self.vk_hash_tag != proof[..VK_HASH_PREFIX_LENGTH] {
            return Err(Groth16Error::Groth16VkeyHashMismatch);
        }

        // Extract the raw Groth16 proof (bytes after the prefix) and parse it.
        let raw_proof_bytes = &proof[VK_HASH_PREFIX_LENGTH..];
        let proof = Groth16Proof::load_from_gnark_bytes(raw_proof_bytes)?;

        // Compute Fr element for hash(public_values) using SHA-256. SP1’s Groth16 circuit expects
        // two public inputs: a. `program_id`, b. `hash(public_values)`.  Since SP1 allows either
        // SHA-256 or Blake3, we try SHA-256 first.
        let pp_sha2_hash = hash_public_inputs_with_fn(public_values, sha256_hash);
        let fr_sha2 =
            Fr::from_slice(&pp_sha2_hash).map_err(|_| Error::FailedToGetFrFromRandomBytes)?;

        // Attempt algebraic verification with SHA-256 hash as the second input.
        if verify_sp1_groth16_algebraic(&self.vk, &proof, &fr_sha2).is_ok() {
            return Ok(());
        }

        // If SHA-256 verification fails, compute the Blake3 hash of `public_values` instead.
        let pp_blake3_hash = hash_public_inputs_with_fn(public_values, blake3_hash);
        let fr_blake3 =
            Fr::from_slice(&pp_blake3_hash).map_err(|_| Error::FailedToGetFrFromRandomBytes)?;

        // Retry algebraic verification using Blake3 hash as the second input.
        verify_sp1_groth16_algebraic(&self.vk, &proof, &fr_blake3)
    }
}

impl ZkVmVerifier for SP1Groth16Verifier {
    fn verify(&self, receipt: &ProofReceipt) -> ZkVmResult<()> {
        self.verify(
            receipt.proof().as_bytes(),
            receipt.public_values().as_bytes(),
        )
        .map_err(|e| ZkVmError::ProofVerificationError(e.to_string()))
    }
}

#[cfg(test)]
mod tests {
    use bn::{AffineG1, AffineG2, Fq, Fq2, Group, G1, G2};
    use rand::thread_rng;
    use sp1_verifier::GROTH16_VK_BYTES;
    use zkaleido::{ProofReceipt, ProofReceiptWithMetadata};

    use crate::verifier::SP1Groth16Verifier;

    fn load_vk_and_proof() -> (SP1Groth16Verifier, ProofReceipt) {
        let program_id_hex = "0000e3572a33647cba427acbaecac23a01e237a8140d2c91b3873457beb5be13";
        let program_id: [u8; 32] = hex::decode(program_id_hex).unwrap().try_into().unwrap();

        let verifier = SP1Groth16Verifier::load(&GROTH16_VK_BYTES, program_id).unwrap();
        let proof_file = format!("./proofs/fibonacci_sp1_0x{}.proof.bin", program_id_hex);
        let receipt = ProofReceiptWithMetadata::load(proof_file)
            .unwrap()
            .receipt()
            .clone();

        (verifier, receipt)
    }

    #[test]
    fn test_valid_proof() {
        let (verifier, receipt) = load_vk_and_proof();
        let res = verifier.verify(
            receipt.proof().as_bytes(),
            receipt.public_values().as_bytes(),
        );
        assert!(res.is_ok());
    }

    #[test]
    fn test_invalid_g1() {
        let (mut verifier, receipt) = load_vk_and_proof();
        let vk_alpha = verifier.vk.g1.alpha.0;
        let alpha_x = vk_alpha.x();
        let alpha_y = vk_alpha.y();

        let mut rng = thread_rng();
        let invalid_alpha_x = Fq::random(&mut rng);

        let res = AffineG1::new(alpha_x, alpha_y);
        assert!(res.is_ok());

        let res = AffineG1::new(invalid_alpha_x, alpha_y);
        assert!(res.is_err());

        let invalid_alpha =
            AffineG1::from_jacobian(G1::new(invalid_alpha_x, alpha_y, Fq::one())).unwrap();
        verifier.vk.g1.alpha.0 = invalid_alpha;

        let res = verifier.verify(
            receipt.proof().as_bytes(),
            receipt.public_values().as_bytes(),
        );
        assert!(res.is_err());

        let random_alpha = AffineG1::from_jacobian(G1::random(&mut rng)).unwrap();
        verifier.vk.g1.alpha.0 = random_alpha;
        let res = verifier.verify(
            receipt.proof().as_bytes(),
            receipt.public_values().as_bytes(),
        );
        assert!(res.is_err());
    }

    #[test]
    fn test_invalid_g2() {
        let (mut verifier, receipt) = load_vk_and_proof();
        let vk_gamma = verifier.vk.g2.gamma.0;
        let gamma_x = vk_gamma.x();
        let gamma_y = vk_gamma.y();
        let invalid_gamma_x = gamma_x + Fq2::one();

        let res = AffineG2::new(gamma_x, gamma_y);
        assert!(res.is_ok());

        let res = AffineG2::new(invalid_gamma_x, gamma_y);
        assert!(res.is_err());

        let invalid_gamma =
            AffineG2::from_jacobian(G2::new(invalid_gamma_x, gamma_y, Fq2::one())).unwrap();
        verifier.vk.g2.gamma.0 = invalid_gamma;

        let res = verifier.verify(
            receipt.proof().as_bytes(),
            receipt.public_values().as_bytes(),
        );
        assert!(res.is_err());

        let mut rng = thread_rng();
        let random_gamma = AffineG2::from_jacobian(G2::random(&mut rng)).unwrap();
        verifier.vk.g2.gamma.0 = random_gamma;
        let res = verifier.verify(
            receipt.proof().as_bytes(),
            receipt.public_values().as_bytes(),
        );
        assert!(res.is_err());
    }
}
