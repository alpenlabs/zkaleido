use risc0_binfmt::tagged_struct;
use risc0_groth16::{Verifier, VerifyingKey};
use risc0_zkp::core::{digest::Digest, hash::sha::Sha256};
use serde::{Deserialize, Serialize};
use zkaleido::{ProofReceipt, ZkVmError, ZkVmResult, ZkVmVerifier};

use crate::{errors::Risc0VerifierError, sha256::Impl as Sha256Impl};

/// Verifier for Risc0 Groth16 proofs.
///
/// This verifier validates Groth16 proofs generated by the Risc0 zkVM system. It ensures that:
/// - The proof was generated using an allowed control ID (zkVM program)
/// - The proof corresponds to the expected ELF image ID
/// - The public values match what was committed to in the proof
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Risc0Groth16Verifier {
    /// Verifying key for Groth16 proofs.
    vk: VerifyingKey,
    /// Control ID for the identity recursion programs (ZKR), represented as a field element
    /// over the BN254 scalar field using Poseidon hash
    bn254_control_id: Digest,
    /// Root of the Merkle tree constructed from allowed control IDs, represented as two
    /// field elements forming a Poseidon2 hash
    control_root: Digest,
    /// ELF image identifier of the program being verified - this ensures the proof
    /// corresponds to the expected zkVM program
    image_id: Digest,
}

impl Risc0Groth16Verifier {
    /// Creates a new `Risc0Groth16Verifier` instance.
    ///
    /// # Arguments
    /// * `vk` - The SNARK verifying key for Groth16 proofs
    /// * `bn254_control_root` - A digest representing the BN254 control root. Its bytes are
    ///   reversed and converted to a field element via hex encoding. This is typically
    ///   `BN254_IDENTITY_CONTROL_ID` from the `risc0_circuit_recursion::control_id` module.
    /// * `allowed_control_root` - A digest whose two halves form the Poseidon2 Merkle root over the
    ///   set of allowed control IDs. This is typically `ALLOWED_CONTROL_ROOT` from the
    ///   `risc0_circuit_recursion::control_id` module.
    /// * `image_id` - The ELF image identifier for the specific program to verify
    pub fn new(
        vk: VerifyingKey,
        bn254_control_id: Digest,
        control_root: Digest,
        image_id: Digest,
    ) -> Self {
        Self {
            vk,
            bn254_control_id,
            control_root,
            image_id,
        }
    }

    /// Verify a Groth16 proof against the given public values.
    ///
    /// This method:
    /// 1. Parses the proof bytes into a `Seal`.
    /// 2. Hashes the provided `public_values` via SHA‐256.
    /// 3. Computes the claim digest combining `image_id` and the public‐params hash.
    /// 4. Builds a verifier with the combined inputs: `(allowed_root.0, allowed_root.1,
    ///    claim_limb0, claim_limb1, bn254_id)`.
    /// 5. Runs verification and returns `true` on success.
    ///
    /// Ref: https://github.com/risc0/risc0/blob/786d7/risc0/zkvm/src/receipt/groth16.rs#L77-L114
    pub fn verify(&self, proof: &[u8], public_values: &[u8]) -> Result<(), Risc0VerifierError> {
        // Compute the SHA-256 hash of the public values (this becomes the journal)
        let public_params_hash = *Sha256Impl::hash_bytes(public_values);

        // Construct the claim digest that represents what we're verifying and split it into field
        // elements
        let claim_digest = compute_claim_digest::<Sha256Impl>(self.image_id, public_params_hash);

        // Create the Groth16 verifier with all public inputs:
        let verifier = Verifier::new(
            proof,
            self.control_root,
            claim_digest,
            self.bn254_control_id,
            &self.vk,
        )
        .map_err(|e| Risc0VerifierError::VerifierCreation(e.to_string()))?;

        // Execute the proof verification
        verifier
            .verify()
            .map_err(|e| Risc0VerifierError::Verification(e.to_string()))
    }
}

/// Computes the “pruned” ReceiptClaim digest for a normal (exit=0) zkVM execution,
/// without pulling in the full `risc0-zkvm` crate. This is a hash-only implementation
/// that can be used across different ZKVMs.
///
/// # Arguments
/// * `image_id` - The ELF image identifier of the program that was executed
/// * `journal` - The digest of the public values that were output by the program
///
/// # Returns
/// A digest representing the complete receipt claim that can be verified against a proof.
///
/// Ref: https://github.com/risc0/risc0/blob/1ea37d6/risc0/zkvm/src/receipt_claim.rs#L71-L92
fn compute_claim_digest<S: Sha256>(image_id: Digest, journal: Digest) -> Digest {
    // Create the post-execution system state digest (empty state with zero journal)
    let post_digest = tagged_struct::<S>("risc0.SystemState", &[Digest::ZERO], &[0]);

    // Both system and user exit codes are zero for successful execution
    let (sys_exit, user_exit) = (0, 0);

    // Input digest is zero since we don't have private inputs to the system
    let input_digest = Digest::ZERO;

    // Create the output digest containing the journal and additional empty metadata
    let output_digest = tagged_struct::<S>("risc0.Output", &[journal, Digest::ZERO], &[]);

    // Construct the final receipt claim by combining all components
    tagged_struct::<S>(
        "risc0.ReceiptClaim",
        &[input_digest, image_id, post_digest, output_digest],
        &[sys_exit, user_exit],
    )
}

impl ZkVmVerifier for Risc0Groth16Verifier {
    fn verify(&self, receipt: &ProofReceipt) -> ZkVmResult<()> {
        self.verify(
            receipt.proof().as_bytes(),
            receipt.public_values().as_bytes(),
        )
        .map_err(|e| ZkVmError::ProofVerificationError(e.to_string()))
    }
}

#[cfg(test)]
mod tests {
    use risc0_circuit_recursion::control_id::{ALLOWED_CONTROL_ROOT, BN254_IDENTITY_CONTROL_ID};
    use risc0_groth16::verifying_key;
    use risc0_zkvm::Digest;
    use zkaleido::{ProofReceipt, ProofReceiptWithMetadata};

    use crate::verifier::Risc0Groth16Verifier;

    fn get_proof_and_image_id() -> (ProofReceipt, [u8; 32]) {
        let image_id_hex = "f4e0413eee665668164b02be80c63b5e71e387ae08b7f9e75e5983cf9eb9518a";
        let image_id: [u8; 32] = hex::decode(image_id_hex).unwrap().try_into().unwrap();
        let proof_file = format!("./proofs/fibonacci_risc0_{}.proof.bin", image_id_hex);

        let receipt = ProofReceiptWithMetadata::load(proof_file)
            .unwrap()
            .receipt()
            .clone();

        (receipt, image_id)
    }

    #[test]
    fn test_groth16_verification() {
        let (receipt, image_id) = get_proof_and_image_id();
        let vk = verifying_key();
        let risc0_verifier = Risc0Groth16Verifier::new(
            vk,
            BN254_IDENTITY_CONTROL_ID,
            ALLOWED_CONTROL_ROOT,
            Digest::from_bytes(image_id),
        );

        let res = risc0_verifier.verify(
            receipt.proof().as_bytes(),
            receipt.public_values().as_bytes(),
        );

        assert!(res.is_ok());
    }
}
