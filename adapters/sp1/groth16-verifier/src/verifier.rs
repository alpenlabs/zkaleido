use bn::Fr;
use sha2::{Digest, Sha256};
use sp1_verifier::{hash_public_inputs_with_fn, sha256_hash};

use crate::{
    conversion::{load_groth16_proof_from_bytes, load_groth16_verifying_key_from_bytes},
    error::{Error, Groth16Error},
    types::Groth16VerifyingKey,
    utils::blake3_hash,
    verification::verify_groth16_algebraic,
};

pub(crate) const VK_HASH_PREFIX_LENGTH: usize = 4;

/// * contains The Groth16 verifying key bytes. Usually this will be the
///   [`static@crate::GROTH16_VK_BYTES`] constant, which is the Groth16 verifying key for the
///   current SP1 version.
pub struct SP1Groth16Verifier {
    /// This is generic for all programs
    groth16_vk: Groth16VerifyingKey,
    groth16_vk_hash: [u8; 4],
    program_id: Fr,
}

impl SP1Groth16Verifier {
    pub fn load(vk_bytes: &[u8], program_id: [u8; 32]) -> Result<Self, Error> {
        // Hash the vk and get the first 4 bytes.
        let groth16_vk_hash: [u8; 4] = Sha256::digest(&vk_bytes)[..VK_HASH_PREFIX_LENGTH]
            .try_into()
            .map_err(|_| Groth16Error::GeneralError(Error::InvalidData))
            .unwrap();

        let groth16_vk = load_groth16_verifying_key_from_bytes(vk_bytes).unwrap();

        let program_id = Fr::from_slice(&program_id).unwrap();
        Ok(SP1Groth16Verifier {
            groth16_vk,
            groth16_vk_hash,
            program_id,
        })
    }

    pub fn verify(&self, proof: &[u8], public_values: &[u8]) -> Result<(), Groth16Error> {
        if proof.len() < VK_HASH_PREFIX_LENGTH {
            return Err(Groth16Error::GeneralError(Error::InvalidData));
        }

        // Check to make sure that this proof was generated by the groth16 proving key corresponding
        // to the given groth16_vk.
        //
        // SP1 prepends the raw Groth16 proof with the first 4 bytes of the groth16 vkey to
        // facilitate this check.
        if self.groth16_vk_hash != proof[..VK_HASH_PREFIX_LENGTH] {
            return Err(Groth16Error::Groth16VkeyHashMismatch);
        }

        let proof = load_groth16_proof_from_bytes(&proof[VK_HASH_PREFIX_LENGTH..]).unwrap();

        let pp_sha2_hash = hash_public_inputs_with_fn(&public_values, sha256_hash);
        let fr = Fr::from_slice(&pp_sha2_hash).unwrap();

        if verify_groth16_algebraic(&self.groth16_vk, &proof, &[self.program_id, fr]).is_ok() {
            return Ok(());
        }

        let pp_blake3_hash = hash_public_inputs_with_fn(&public_values, blake3_hash);
        let fr = Fr::from_slice(&pp_blake3_hash).unwrap();
        verify_groth16_algebraic(&self.groth16_vk, &proof, &[self.program_id, fr])
    }
}

#[cfg(test)]
mod tests {
    use sp1_verifier::GROTH16_VK_BYTES;
    use zkaleido::ProofReceipt;

    use crate::verifier::SP1Groth16Verifier;

    #[test]
    fn test_load_and_verify() {
        let program_id_hex = "0000e3572a33647cba427acbaecac23a01e237a8140d2c91b3873457beb5be13";
        let program_id: [u8; 32] = hex::decode(program_id_hex).unwrap().try_into().unwrap();

        let vk = SP1Groth16Verifier::load(&GROTH16_VK_BYTES, program_id).unwrap();
        let proof_file = format!("./proofs/fibonacci_sp1_0x{}.proof.bin", program_id_hex);
        let receipt = ProofReceipt::load(proof_file).unwrap();
        let res = vk.verify(
            receipt.proof().as_bytes(),
            receipt.public_values().as_bytes(),
        );
        assert!(res.is_ok());
    }
}
