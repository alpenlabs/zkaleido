use risc0_binfmt::tagged_struct;
use risc0_groth16::{fr_from_hex_string, split_digest, Fr, Seal, Verifier, VerifyingKey};
use risc0_zkp::core::{digest::Digest, hash::sha::Sha256};
use serde::{Deserialize, Serialize};
use zkaleido::{ProofReceipt, ZkVmError, ZkVmProofError, ZkVmResult, ZkVmVerifier};

use crate::{errors::Risc0VerifierError, sha256::Impl as Sha256Impl};

/// Verifier for Risc0 Groth16 proofs.
///
/// This verifier validates Groth16 proofs generated by the Risc0 zkVM system. It ensures that:
/// - The proof was generated using an allowed control ID (zkVM program)
/// - The proof corresponds to the expected ELF image ID
/// - The public values match what was committed to in the proof
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Risc0Groth16Verifier {
    /// Verifying key for Groth16 proofs.
    vk: VerifyingKey,
    /// Control ID for the identity recursion programs (ZKR), represented as a field element
    /// over the BN254 scalar field using Poseidon hash
    bn254_id: Fr,
    /// Root of the Merkle tree constructed from allowed control IDs, represented as two
    /// field elements forming a Poseidon2 hash
    allowed_root: (Fr, Fr),
    /// ELF image identifier of the program being verified - this ensures the proof
    /// corresponds to the expected zkVM program
    image_id: Digest,
}

impl Risc0Groth16Verifier {
    /// Creates a new `Risc0Groth16Verifier` instance.
    ///
    /// # Arguments
    /// * `vk` - The SNARK verifying key for Groth16 proofs
    /// * `bn254_control_root` - A digest representing the BN254 control root. Its bytes are
    ///   reversed and converted to a field element via hex encoding. This is typically
    ///   `BN254_IDENTITY_CONTROL_ID` from the `risc0_circuit_recursion::control_id` module.
    /// * `allowed_control_root` - A digest whose two halves form the Poseidon2 Merkle root over the
    ///   set of allowed control IDs. This is typically `ALLOWED_CONTROL_ROOT` from the
    ///   `risc0_circuit_recursion::control_id` module.
    /// * `image_id` - The ELF image identifier for the specific program to verify
    pub fn load(
        vk: VerifyingKey,
        bn254_control_root: Digest,
        allowed_control_root: Digest,
        image_id: Digest,
    ) -> Result<Self, Risc0VerifierError> {
        // Convert BN254 control root to field element
        // The bytes are reversed to match the expected endianness
        let mut bn254_id = bn254_control_root;
        bn254_id.as_mut_bytes().reverse();

        // Split the allowed control root digest into two field elements
        let (a0, a1) = split_digest(allowed_control_root)
            .map_err(|e| Risc0VerifierError::SplitDigest(e.to_string()))?;

        // Convert the reversed bytes to a field element via hex encoding
        let bn254_id = fr_from_hex_string(&hex::encode(bn254_id))
            .map_err(|e| Risc0VerifierError::InvalidFr(e.to_string()))?;

        Ok(Self {
            vk,
            bn254_id,
            allowed_root: (a0, a1),
            image_id,
        })
    }

    /// Verify a Groth16 proof against the given public values.
    ///
    /// This method:
    /// 1. Parses the proof bytes into a `Seal`.
    /// 2. Hashes the provided `public_values` via SHA‐256.
    /// 3. Computes the claim digest combining `image_id` and the public‐params hash.
    /// 4. Builds a verifier with the combined inputs: `(allowed_root.0, allowed_root.1,
    ///    claim_limb0, claim_limb1, bn254_id)`.
    /// 5. Runs verification and returns `true` on success.
    ///
    /// Ref: https://github.com/risc0/risc0/blob/786d7/risc0/zkvm/src/receipt/groth16.rs#L77-L114
    pub fn verify(&self, proof: &[u8], public_values: &[u8]) -> Result<(), Risc0VerifierError> {
        // Parse the proof bytes into a Groth16 seal
        let seal =
            Seal::from_vec(proof).map_err(|e| Risc0VerifierError::ProofParse(e.to_string()))?;

        // Compute the SHA-256 hash of the public values (this becomes the journal)
        let public_params_hash = *Sha256Impl::hash_bytes(public_values);

        // Construct the claim digest that represents what we're verifying and split it into field
        // elements
        let claim_digest = compute_claim_digest::<Sha256Impl>(self.image_id, public_params_hash);
        let (c0, c1) = split_digest(claim_digest)
            .map_err(|e| Risc0VerifierError::SplitDigest(e.to_string()))?;

        // Extract the allowed root components
        let (a0, a1) = self.allowed_root.clone();

        // Create the Groth16 verifier with all public inputs:
        // [allowed_root_0, allowed_root_1, claim_limb_0, claim_limb_1, bn254_id]
        let verifier = Verifier::new(&seal, &[a0, a1, c0, c1, self.bn254_id.clone()], &self.vk)
            .map_err(|e| Risc0VerifierError::VerifierCreation(e.to_string()))?;

        // Execute the proof verification
        verifier
            .verify()
            .map_err(|e| Risc0VerifierError::Verification(e.to_string()))
    }
}

/// Computes the “pruned” ReceiptClaim digest for a normal (exit=0) zkVM execution,
/// without pulling in the full `risc0-zkvm` crate. This is a hash-only implementation
/// that can be used across different ZKVMs.
///
/// # Arguments
/// * `image_id` - The ELF image identifier of the program that was executed
/// * `journal` - The digest of the public values that were output by the program
///
/// # Returns
/// A digest representing the complete receipt claim that can be verified against a proof.
///
/// Ref: https://github.com/risc0/risc0/blob/1ea37d6/risc0/zkvm/src/receipt_claim.rs#L71-L92
fn compute_claim_digest<S: Sha256>(image_id: Digest, journal: Digest) -> Digest {
    // Create the post-execution system state digest (empty state with zero journal)
    let post_digest = tagged_struct::<S>("risc0.SystemState", &[Digest::ZERO], &[0]);

    // Both system and user exit codes are zero for successful execution
    let (sys_exit, user_exit) = (0, 0);

    // Input digest is zero since we don't have private inputs to the system
    let input_digest = Digest::ZERO;

    // Create the output digest containing the journal and additional empty metadata
    let output_digest = tagged_struct::<S>("risc0.Output", &[journal, Digest::ZERO], &[]);

    // Construct the final receipt claim by combining all components
    tagged_struct::<S>(
        "risc0.ReceiptClaim",
        &[input_digest, image_id, post_digest, output_digest],
        &[sys_exit, user_exit],
    )
}

#[derive(Debug, Clone)]
pub struct Risc0Groth16ProofReceipt(ProofReceipt);

impl TryFrom<ProofReceipt> for Risc0Groth16ProofReceipt {
    type Error = ZkVmProofError;
    fn try_from(value: ProofReceipt) -> Result<Self, Self::Error> {
        Ok(Risc0Groth16ProofReceipt(value))
    }
}

impl TryFrom<Risc0Groth16ProofReceipt> for ProofReceipt {
    type Error = ZkVmProofError;
    fn try_from(value: Risc0Groth16ProofReceipt) -> Result<Self, Self::Error> {
        Ok(value.0)
    }
}

impl ZkVmVerifier for Risc0Groth16Verifier {
    type ZkVmProofReceipt = Risc0Groth16ProofReceipt;

    fn verify_inner(&self, receipt: &Self::ZkVmProofReceipt) -> ZkVmResult<()> {
        self.verify(
            receipt.0.proof().as_bytes(),
            receipt.0.public_values().as_bytes(),
        )
        .map_err(|e| ZkVmError::ProofVerificationError(e.to_string()))
    }
}

#[cfg(test)]
mod tests {
    use risc0_circuit_recursion::control_id::{ALLOWED_CONTROL_ROOT, BN254_IDENTITY_CONTROL_ID};
    use risc0_groth16::verifying_key;
    use risc0_zkvm::Digest;
    use zkaleido::ProofReceipt;

    use crate::verifier::Risc0Groth16Verifier;

    fn get_proof_and_image_id() -> (ProofReceipt, [u8; 32]) {
        let image_id_hex = "7f3599b6e5c45edc6c2dcd88a9df76d1c9fce38cfb2afc8e5615f154d878009b";
        let image_id: [u8; 32] = hex::decode(image_id_hex).unwrap().try_into().unwrap();
        let proof_file = format!("./proofs/fibonacci_risc0_{}.proof.bin", image_id_hex);

        let receipt = ProofReceipt::load(proof_file).unwrap();

        (receipt, image_id)
    }

    #[test]
    fn test_groth16_verification() {
        let (receipt, image_id) = get_proof_and_image_id();
        let vk = verifying_key();
        let risc0_verifier = Risc0Groth16Verifier::load(
            vk,
            BN254_IDENTITY_CONTROL_ID,
            ALLOWED_CONTROL_ROOT,
            Digest::from_bytes(image_id),
        )
        .unwrap();

        let res = risc0_verifier.verify(
            receipt.proof().as_bytes(),
            receipt.public_values().as_bytes(),
        );

        assert!(res.is_ok());
    }
}
